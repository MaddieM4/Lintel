.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Path::Router 3pm"
.TH Path::Router 3pm "2015-01-13" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Path::Router \- A tool for routing paths
.SH "VERSION"
.IX Header "VERSION"
version 0.14
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  my $router = Path::Router\->new;
\&
\&  $router\->add_route(\*(Aqblog\*(Aq => (
\&      defaults => {
\&          controller => \*(Aqblog\*(Aq,
\&          action     => \*(Aqindex\*(Aq,
\&      },
\&      # you can provide a fixed "target"
\&      # for a match as well, this can be
\&      # anything you want it to be ...
\&      target => My::App\->get_controller(\*(Aqblog\*(Aq)\->get_action(\*(Aqindex\*(Aq)
\&  ));
\&
\&  $router\->add_route(\*(Aqblog/:year/:month/:day\*(Aq => (
\&      defaults => {
\&          controller => \*(Aqblog\*(Aq,
\&          action     => \*(Aqshow_date\*(Aq,
\&      },
\&      # validate with ...
\&      validations => {
\&          # ... raw\-Regexp refs
\&          year       => qr/\ed{4}/,
\&          # ... custom Moose types you created
\&          month      => \*(AqNumericMonth\*(Aq,
\&          # ... Moose anon\-subtypes created inline
\&          day        => subtype(\*(AqInt\*(Aq => where { $_ <= 31 }),
\&      }
\&  ));
\&
\&  $router\->add_route(\*(Aqblog/:action/?:id\*(Aq => (
\&      defaults => {
\&          controller => \*(Aqblog\*(Aq,
\&      },
\&      validations => {
\&          action  => qr/\eD+/,
\&          id      => \*(AqInt\*(Aq,  # also use plain Moose types too
\&      }
\&  ));
\&
\&  # even include other routers
\&  $router\->include_router( \*(Aqpolls/\*(Aq => $another_router );
\&
\&  # ... in your dispatcher
\&
\&  # returns a Path::Router::Route::Match object
\&  my $match = $router\->match(\*(Aq/blog/edit/15\*(Aq);
\&
\&  # ... in your code
\&
\&  my $uri = $router\->uri_for(
\&      controller => \*(Aqblog\*(Aq,
\&      action     => \*(Aqshow_date\*(Aq,
\&      year       => 2006,
\&      month      => 10,
\&      day        => 5,
\&  );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a way of deconstructing paths into parameters
suitable for dispatching on. It also provides the inverse in that
it will take a list of parameters, and construct an appropriate
uri for it.
.SS "Reversable"
.IX Subsection "Reversable"
This module places a high degree of importance on reversability.
The value produced by a path match can be passed back in and you
will get the same path you originally put in. The result of this
is that it removes ambiguity and therefore reduces the number of
possible mis-routings.
.SS "Verifyable"
.IX Subsection "Verifyable"
This module also provides additional tools you can use to test
and verify the integrity of your router. These include:
.IP "\(bu" 4
An interactive shell in which you can test various paths and see the
match it will return, and also test the reversability of that match.
.IP "\(bu" 4
A Test::Path::Router module which can be used in your applications
test suite to easily verify the integrity of your paths.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew\fR" 4
.IX Item "new"
.PD 0
.IP "\fBadd_route ($path, ?%options)\fR" 4
.IX Item "add_route ($path, ?%options)"
.PD
Adds a new route to the \fIend\fR of the routes list.
.ie n .IP "\fBinsert_route ($path, \fB%options\fB)\fR" 4
.el .IP "\fBinsert_route ($path, \f(CB%options\fB)\fR" 4
.IX Item "insert_route ($path, %options)"
Adds a new route to the routes list. You may specify an \f(CW\*(C`at\*(C'\fR parameter, which would
indicate the position where you want to insert your newly created route. The \f(CW\*(C`at\*(C'\fR
parameter is the \f(CW\*(C`index\*(C'\fR position in the list, so it starts at 0.
.Sp
Examples:
.Sp
.Vb 5
\&    # You have more than three paths, insert a new route at
\&    # the 4th item
\&    $router\->insert_route($path => (
\&        at => 3, %options
\&    ));
\&
\&    # If you have less items than the index, then it\*(Aqs the same as
\&    # as add_route \-\- it\*(Aqs just appended to the end of the list
\&    $router\->insert_route($path => (
\&        at => 1_000_000, %options
\&    ));
\&
\&    # If you want to prepend, omit "at", or specify 0
\&    $router\->insert_Route($path => (
\&        at => 0, %options
\&    ));
.Ve
.ie n .IP "\fBinclude_router ( \fB$path\fB, \f(BI$other_router\fB )\fR" 4
.el .IP "\fBinclude_router ( \f(CB$path\fB, \f(CB$other_router\fB )\fR" 4
.IX Item "include_router ( $path, $other_router )"
These extracts all the route from \f(CW$other_router\fR and includes them into
the invocant router and prepends \f(CW$path\fR to all their paths.
.Sp
It should be noted that this does \fBnot\fR do any kind of redispatch to the
\&\f(CW$other_router\fR, it actually extracts all the paths from \f(CW$other_router\fR
and inserts them into the invocant router. This means any changes to
\&\f(CW$other_router\fR after inclusion will not be reflected in the invocant.
.IP "\fBroutes\fR" 4
.IX Item "routes"
.PD 0
.IP "\fBmatch ($path)\fR" 4
.IX Item "match ($path)"
.PD
Return a Path::Router::Route::Match object for the first route that matches the
given \f(CW$path\fR, or \f(CW\*(C`undef\*(C'\fR if no routes match.
.IP "\fBuri_for (%path_descriptor)\fR" 4
.IX Item "uri_for (%path_descriptor)"
Find the path that, when passed to \f(CW\*(C`$router\->match\*(C'\fR, would produce the
given arguments.  Returns the path without any leading \f(CW\*(C`/\*(C'\fR.  Returns \f(CW\*(C`undef\*(C'\fR
if no routes match.
.IP "\fBmeta\fR" 4
.IX Item "meta"
.SH "DEBUGGING"
.IX Header "DEBUGGING"
You can turn on the verbose debug logging with the \f(CW\*(C`PATH_ROUTER_DEBUG\*(C'\fR
environment variable.
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no
exception. If you find a bug please either email me, or add the bug
to cpan-RT.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan.little@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2008\-2011 Infinity Interactive, Inc.
.PP
<http://www.iinteractive.com>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Stevan Little <stevan@iinteractive.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2015 by Infinity Interactive.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
