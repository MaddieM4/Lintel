.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Future::Utils 3pm"
.TH Future::Utils 3pm "2015-06-21" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
"Future::Utils" \- utility functions for working with "Future" objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Future::Utils qw( call_with_escape );
\&
\& my $result_f = call_with_escape {
\&    my $escape_f = shift;
\&    my $f = ...
\&       $escape_f\->done( "immediate result" );
\&       ...
\& };
.Ve
.PP

.PP
.Vb 1
\& use Future::Utils qw( repeat try_repeat try_repeat_until_success );
\&
\& my $eventual_f = repeat {
\&    my $trial_f = ...
\&    return $trial_f;
\& } while => sub { my $f = shift; return want_more($f) };
\&
\& my $eventual_f = repeat {
\&    ...
\&    return $trail_f;
\& } until => sub { my $f = shift; return acceptable($f) };
\&
\& my $eventual_f = repeat {
\&    my $item = shift;
\&    ...
\&    return $trial_f;
\& } foreach => \e@items;
\&
\& my $eventual_f = try_repeat {
\&    my $trial_f = ...
\&    return $trial_f;
\& } while => sub { ... };
\&
\& my $eventual_f = try_repeat_until_success {
\&    ...
\&    return $trial_f;
\& };
\&
\& my $eventual_f = try_repeat_until_success {
\&    my $item = shift;
\&    ...
\&    return $trial_f;
\& } foreach => \e@items;
.Ve
.PP

.PP
.Vb 1
\& use Future::Utils qw( fmap_concat fmap_scalar fmap_void );
\&
\& my $result_f = fmap_concat {
\&    my $item = shift;
\&    ...
\&    return $item_f;
\& } foreach => \e@items, concurrent => 4;
\&
\& my $result_f = fmap_scalar {
\&    my $item = shift;
\&    ...
\&    return $item_f;
\& } foreach => \e@items, concurrent => 8;
\&
\& my $done_f = fmap_void {
\&    my $item = shift;
\&    ...
\&    return $item_f;
\& } foreach => \e@items, concurrent => 10;
.Ve
.SH "INVOKING A BLOCK OF CODE"
.IX Header "INVOKING A BLOCK OF CODE"
.ie n .SS "$f = call { \s-1CODE \s0}"
.el .SS "\f(CW$f\fP = call { \s-1CODE \s0}"
.IX Subsection "$f = call { CODE }"
The \f(CW\*(C`call\*(C'\fR function invokes a block of code that returns a future, and simply
returns the future it returned. The code is wrapped in an \f(CW\*(C`eval {}\*(C'\fR block, so
that if it throws an exception this is turned into an immediate failed
\&\f(CW\*(C`Future\*(C'\fR. If the code does not return a \f(CW\*(C`Future\*(C'\fR, then an immediate failed
\&\f(CW\*(C`Future\*(C'\fR instead.
.PP
(This is equivalent to using \f(CW\*(C`Future\->call\*(C'\fR, but is duplicated here for
completeness).
.ie n .SS "$f = call_with_escape { \s-1CODE \s0}"
.el .SS "\f(CW$f\fP = call_with_escape { \s-1CODE \s0}"
.IX Subsection "$f = call_with_escape { CODE }"
The \f(CW\*(C`call_with_escape\*(C'\fR function invokes a block of code that returns a
future, and passes in a separate future (called here an \*(L"escape future\*(R").
Normally this is equivalent to the simple \f(CW\*(C`call\*(C'\fR function. However, if the
code captures this future and completes it by calling \f(CW\*(C`done\*(C'\fR or \f(CW\*(C`fail\*(C'\fR on
it, the future returned by \f(CW\*(C`call_with_escape\*(C'\fR immediately completes with this
result, and the future returned by the code itself is cancelled.
.PP
This can be used to implement short-circuit return from an iterating loop or
complex sequence of code, or immediate fail that bypasses failure handling
logic in the code itself, or several other code patterns.
.PP
.Vb 1
\& $f = $code\->( $escape_f )
.Ve
.PP
(This can be considered similar to \f(CW\*(C`call\-with\-escape\-continuation\*(C'\fR as found
in some Scheme implementations).
.SH "REPEATING A BLOCK OF CODE"
.IX Header "REPEATING A BLOCK OF CODE"
The \f(CW\*(C`repeat\*(C'\fR function provides a way to repeatedly call a block of code that
returns a Future (called here a \*(L"trial future\*(R") until some ending condition
is satisfied. The \f(CW\*(C`repeat\*(C'\fR function itself returns a \f(CW\*(C`Future\*(C'\fR to represent
running the repeating loop until that end condition (called here the \*(L"eventual
future\*(R"). The first time the code block is called, it is passed no arguments,
and each subsequent invocation is passed the previous trial future.
.PP
The result of the eventual future is the result of the last trial future.
.PP
If the eventual future is cancelled, the latest trial future will be
cancelled.
.PP
If some specific subclass or instance of \f(CW\*(C`Future\*(C'\fR is required as the return
value, it can be passed as the \f(CW\*(C`return\*(C'\fR argument. Otherwise the return value
will be constructed by cloning the first non-immediate trial \f(CW\*(C`Future\*(C'\fR.
.ie n .SS "$future = repeat { \s-1CODE \s0} while => \s-1CODE\s0"
.el .SS "\f(CW$future\fP = repeat { \s-1CODE \s0} while => \s-1CODE\s0"
.IX Subsection "$future = repeat { CODE } while => CODE"
Repeatedly calls the \f(CW\*(C`CODE\*(C'\fR block while the \f(CW\*(C`while\*(C'\fR condition returns a true
value. Each time the trial future completes, the \f(CW\*(C`while\*(C'\fR condition is passed
the trial future.
.PP
.Vb 2
\& $trial_f = $code\->( $previous_trial_f )
\& $again = $while\->( $trial_f )
.Ve
.PP
If the \f(CW$code\fR block dies entirely and throws an exception, this will be
caught and considered as an immediately-failed \f(CW\*(C`Future\*(C'\fR with the exception as
the future's failure. The exception will not be propagated to the caller.
.ie n .SS "$future = repeat { \s-1CODE \s0} until => \s-1CODE\s0"
.el .SS "\f(CW$future\fP = repeat { \s-1CODE \s0} until => \s-1CODE\s0"
.IX Subsection "$future = repeat { CODE } until => CODE"
Repeatedly calls the \f(CW\*(C`CODE\*(C'\fR block until the \f(CW\*(C`until\*(C'\fR condition returns a true
value. Each time the trial future completes, the \f(CW\*(C`until\*(C'\fR condition is passed
the trial future.
.PP
.Vb 2
\& $trial_f = $code\->( $previous_trial_f )
\& $accept = $until\->( $trial_f )
.Ve
.ie n .SS "$future = repeat { \s-1CODE \s0} foreach => \s-1ARRAY,\s0 otherwise => \s-1CODE\s0"
.el .SS "\f(CW$future\fP = repeat { \s-1CODE \s0} foreach => \s-1ARRAY,\s0 otherwise => \s-1CODE\s0"
.IX Subsection "$future = repeat { CODE } foreach => ARRAY, otherwise => CODE"
Calls the \f(CW\*(C`CODE\*(C'\fR block once for each value obtained from the array, passing
in the value as the first argument (before the previous trial future). When
there are no more items left in the array, the \f(CW\*(C`otherwise\*(C'\fR code is invoked
once and passed the last trial future, if there was one, or \f(CW\*(C`undef\*(C'\fR if the
list was originally empty. The result of the eventual future will be the
result of the future returned from \f(CW\*(C`otherwise\*(C'\fR.
.PP
The referenced array may be modified by this operation.
.PP
.Vb 2
\& $trial_f = $code\->( $item, $previous_trial_f )
\& $final_f = $otherwise\->( $last_trial_f )
.Ve
.PP
The \f(CW\*(C`otherwise\*(C'\fR code is optional; if not supplied then the result of the
eventual future will simply be that of the last trial. If there was no trial,
because the \f(CW\*(C`foreach\*(C'\fR list was already empty, then an immediate successful
future with an empty result is returned.
.ie n .SS "$future = repeat { \s-1CODE \s0} foreach => \s-1ARRAY,\s0 while => \s-1CODE, ...\s0"
.el .SS "\f(CW$future\fP = repeat { \s-1CODE \s0} foreach => \s-1ARRAY,\s0 while => \s-1CODE, ...\s0"
.IX Subsection "$future = repeat { CODE } foreach => ARRAY, while => CODE, ..."
.ie n .SS "$future = repeat { \s-1CODE \s0} foreach => \s-1ARRAY,\s0 until => \s-1CODE, ...\s0"
.el .SS "\f(CW$future\fP = repeat { \s-1CODE \s0} foreach => \s-1ARRAY,\s0 until => \s-1CODE, ...\s0"
.IX Subsection "$future = repeat { CODE } foreach => ARRAY, until => CODE, ..."
Combines the effects of \f(CW\*(C`foreach\*(C'\fR with \f(CW\*(C`while\*(C'\fR or \f(CW\*(C`until\*(C'\fR. Calls the
\&\f(CW\*(C`CODE\*(C'\fR block once for each value obtained from the array, until the array is
exhausted or the given ending condition is satisfied.
.PP
If a \f(CW\*(C`while\*(C'\fR or \f(CW\*(C`until\*(C'\fR condition is combined with \f(CW\*(C`otherwise\*(C'\fR, the
\&\f(CW\*(C`otherwise\*(C'\fR code will only be run if the array was entirely exhausted. If the
operation is terminated early due to the \f(CW\*(C`while\*(C'\fR or \f(CW\*(C`until\*(C'\fR condition being
satisfied, the eventual result will simply be that of the last trial that was
executed.
.ie n .SS "$future = repeat { \s-1CODE \s0} generate => \s-1CODE,\s0 otherwise => \s-1CODE\s0"
.el .SS "\f(CW$future\fP = repeat { \s-1CODE \s0} generate => \s-1CODE,\s0 otherwise => \s-1CODE\s0"
.IX Subsection "$future = repeat { CODE } generate => CODE, otherwise => CODE"
Calls the \f(CW\*(C`CODE\*(C'\fR block once for each value obtained from the generator code,
passing in the value as the first argument (before the previous trial future).
When the generator returns an empty list, the \f(CW\*(C`otherwise\*(C'\fR code is invoked and
passed the last trial future, if there was one, otherwise \f(CW\*(C`undef\*(C'\fR if the
generator never returned a value. The result of the eventual future will be
the result of the future returned from \f(CW\*(C`otherwise\*(C'\fR.
.PP
.Vb 2
\& $trial_f = $code\->( $item, $previous_trial_f )
\& $final_f = $otherwise\->( $last_trial_f )
\&
\& ( $item ) = $generate\->()
.Ve
.PP
The generator is called in list context but should return only one item per
call. Subsequent values will be ignored. When it has no more items to return
it should return an empty list.
.PP
For backward compatibility this function will allow a \f(CW\*(C`while\*(C'\fR or \f(CW\*(C`until\*(C'\fR
condition that requests a failure be repeated, but it will print a warning if
it has to do that. To apply repeating behaviour that can catch and retry
failures, use \f(CW\*(C`try_repeat\*(C'\fR instead. This old behaviour is now deprecated and
will be removed in the next version.
.ie n .SS "$future = try_repeat { \s-1CODE \s0} ..."
.el .SS "\f(CW$future\fP = try_repeat { \s-1CODE \s0} ..."
.IX Subsection "$future = try_repeat { CODE } ..."
A variant of \f(CW\*(C`repeat\*(C'\fR that doesn't warn when the trial fails and the
condition code asks for it to be repeated.
.PP
In some later version the \f(CW\*(C`repeat\*(C'\fR function will be changed so that if a
trial future fails, then the eventual future will immediately fail as well,
making its semantics a little closer to that of a \f(CW\*(C`while {}\*(C'\fR loop in Perl.
Code that specifically wishes to catch failures in trial futures and retry
the block should use \f(CW\*(C`try_repeat\*(C'\fR specifically.
.ie n .SS "$future = try_repeat_until_success { \s-1CODE \s0} ..."
.el .SS "\f(CW$future\fP = try_repeat_until_success { \s-1CODE \s0} ..."
.IX Subsection "$future = try_repeat_until_success { CODE } ..."
A shortcut to calling \f(CW\*(C`try_repeat\*(C'\fR with an ending condition that simply tests
for a successful result from a future. May be combined with \f(CW\*(C`foreach\*(C'\fR or
\&\f(CW\*(C`generate\*(C'\fR.
.PP
This function used to be called \f(CW\*(C`repeat_until_success\*(C'\fR, and is currently
aliased as this name as well.
.SH "APPLYING A FUNCTION TO A LIST"
.IX Header "APPLYING A FUNCTION TO A LIST"
The \f(CW\*(C`fmap\*(C'\fR family of functions provide a way to call a block of code that
returns a Future (called here an \*(L"item future\*(R") once per item in a given
list, or returned by a generator function. The \f(CW\*(C`fmap*\*(C'\fR functions themselves
return a \f(CW\*(C`Future\*(C'\fR to represent the ongoing operation, which completes when
every item's future has completed.
.PP
While this behaviour can also be implemented using \f(CW\*(C`repeat\*(C'\fR, the main reason
to use an \f(CW\*(C`fmap\*(C'\fR function is that the individual item operations are
considered as independent, and thus more than one can be outstanding
concurrently. An argument can be passed to the function to indicate how many
items to start initially, and thereafter it will keep that many of them
running concurrently until all of the items are done, or until any of them
fail. If an individual item future fails, the overall result future will be
marked as failing with the same failure, and any other pending item futures
that are outstanding at the time will be cancelled.
.PP
The following named arguments are common to each \f(CW\*(C`fmap*\*(C'\fR function:
.IP "foreach => \s-1ARRAY\s0" 8
.IX Item "foreach => ARRAY"
Provides the list of items to iterate over, as an \f(CW\*(C`ARRAY\*(C'\fR reference.
.Sp
The referenced array will be modified by this operation, \f(CW\*(C`shift\*(C'\fRing one item
from it each time. The can \f(CW\*(C`push\*(C'\fR more items to this array as it runs, and
they will be included in the iteration.
.IP "generate => \s-1CODE\s0" 8
.IX Item "generate => CODE"
Provides the list of items to iterate over, by calling the generator function
once for each required item. The function should return a single item, or an
empty list to indicate it has no more items.
.Sp
.Vb 1
\& ( $item ) = $generate\->()
.Ve
.Sp
This function will be invoked each time any previous item future has completed
and may be called again even after it has returned empty.
.IP "concurrent => \s-1INT\s0" 8
.IX Item "concurrent => INT"
Gives the number of item futures to keep outstanding. By default this value
will be 1 (i.e. no concurrency); larger values indicate that multiple item
futures will be started at once.
.IP "return => Future" 8
.IX Item "return => Future"
Normally, a new instance is returned by cloning the first non-immediate future
returned as an item future. By passing a new instance as the \f(CW\*(C`return\*(C'\fR
argument, the result will be put into the given instance. This can be used to
return subclasses, or specific instances.
.PP
In each case, the main code block will be called once for each item in the
list, passing in the item as the only argument:
.PP
.Vb 1
\& $item_f = $code\->( $item )
.Ve
.PP
The expected return value from each item's future, and the value returned from
the result future will differ in each function's case; they are documented
below.
.ie n .SS "$future = fmap_concat { \s-1CODE \s0} ..."
.el .SS "\f(CW$future\fP = fmap_concat { \s-1CODE \s0} ..."
.IX Subsection "$future = fmap_concat { CODE } ..."
This version of \f(CW\*(C`fmap\*(C'\fR expects each item future to return a list of zero or
more values, and the overall result will be the concatenation of all these
results. It acts like a future-based equivalent to Perl's \f(CW\*(C`map\*(C'\fR operator.
.PP
The results are returned in the order of the original input values, not in the
order their futures complete in. Because of the intermediate storage of
\&\f(CW\*(C`ARRAY\*(C'\fR references and final flattening operation used to implement this
behaviour, this function is slightly less efficient than \f(CW\*(C`fmap_scalar\*(C'\fR or
\&\f(CW\*(C`fmap_void\*(C'\fR in cases where item futures are expected only ever to return one,
or zero values, respectively.
.PP
This function is also available under the name of simply \f(CW\*(C`fmap\*(C'\fR to emphasise
its similarity to perl's \f(CW\*(C`map\*(C'\fR keyword.
.ie n .SS "$future = fmap_scalar { \s-1CODE \s0} ..."
.el .SS "\f(CW$future\fP = fmap_scalar { \s-1CODE \s0} ..."
.IX Subsection "$future = fmap_scalar { CODE } ..."
This version of \f(CW\*(C`fmap\*(C'\fR acts more like the \f(CW\*(C`map\*(C'\fR functions found in Scheme or
Haskell; it expects that each item future returns only one value, and the
overall result will be a list containing these, in order of the original input
items. If an item future returns more than one value the others will be
discarded. If it returns no value, then \f(CW\*(C`undef\*(C'\fR will be substituted in its
place so that the result list remains in correspondence with the input list.
.PP
This function is also available under the shorter name of \f(CW\*(C`fmap1\*(C'\fR.
.ie n .SS "$future = fmap_void { \s-1CODE \s0} ..."
.el .SS "\f(CW$future\fP = fmap_void { \s-1CODE \s0} ..."
.IX Subsection "$future = fmap_void { CODE } ..."
This version of \f(CW\*(C`fmap\*(C'\fR does not collect any results from its item futures, it
simply waits for them all to complete. Its result future will provide no
values.
.PP
While not a map in the strictest sense, this variant is still useful as a way
to control concurrency of a function call iterating over a list of items,
obtaining its results by some other means (such as side-effects on captured
variables, or some external system).
.PP
This function is also available under the shorter name of \f(CW\*(C`fmap0\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
