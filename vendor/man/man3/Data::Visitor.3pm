.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Visitor 3pm"
.TH Data::Visitor 3pm "2013-06-24" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Visitor \- Visitor style traversal of Perl data structures
.SH "VERSION"
.IX Header "VERSION"
version 0.30
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&        # NOTE
\&        # You probably want to use Data::Visitor::Callback for trivial things
\&
\&        package FooCounter;
\&        use Moose;
\&
\&        extends qw(Data::Visitor);
\&
\&        has number_of_foos => (
\&                isa => "Int",
\&                is  => "rw",
\&                default => 0,
\&        );
\&
\&        sub visit_value {
\&                my ( $self, $data ) = @_;
\&
\&                if ( defined $data and $data eq "foo" ) {
\&                        $self\->number_of_foos( $self\->number_of_foos + 1 );
\&                }
\&
\&                return $data;
\&        }
\&
\&        my $counter = FooCounter\->new;
\&
\&        $counter\->visit( {
\&                this => "that",
\&                some_foos => [ qw/foo foo bar foo/ ],
\&                the_other => "foo",
\&        });
\&
\&        $counter\->number_of_foos; # this is now 4
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a simple visitor implementation for Perl values.
.PP
It has a main dispatcher method, \f(CW\*(C`visit\*(C'\fR, which takes a single perl value and
then calls the methods appropriate for that value.
.PP
It can recursively map (cloning as necessary) or just traverse most structures,
with support for per object behavior, circular structures, visiting tied
structures, and all ref types (hashes, arrays, scalars, code, globs).
.PP
Data::Visitor is meant to be subclassed, but also ships with a callback
driven subclass, Data::Visitor::Callback.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "visit $data" 4
.el .IP "visit \f(CW$data\fR" 4
.IX Item "visit $data"
This method takes any Perl value as it's only argument, and dispatches to the
various other visiting methods using \f(CW\*(C`visit_no_rec_check\*(C'\fR, based on the data's
type.
.Sp
If the value is a reference and has already been seen then \f(CW\*(C`visit_seen\*(C'\fR is
called.
.ie n .IP "visit_seen $data, $first_result" 4
.el .IP "visit_seen \f(CW$data\fR, \f(CW$first_result\fR" 4
.IX Item "visit_seen $data, $first_result"
When an already seen value is encountered again it's typically replaced with
the result of the first visitation of that value. The value and the result of
the first visitation are passed as arguments.
.Sp
Returns \f(CW$first_result\fR.
.ie n .IP "visit_no_rec_check $data" 4
.el .IP "visit_no_rec_check \f(CW$data\fR" 4
.IX Item "visit_no_rec_check $data"
Called for any value that has not yet been seen. Does the actual type based
dispatch for \f(CW\*(C`visit\*(C'\fR.
.Sp
Should not be called directly unless forcing a circular structure to be
unfolded. Use with caution as this may cause infinite recursion.
.ie n .IP "visit_object $object" 4
.el .IP "visit_object \f(CW$object\fR" 4
.IX Item "visit_object $object"
If the value is a blessed object, \f(CW\*(C`visit\*(C'\fR calls this method. The base
implementation will just forward to \f(CW\*(C`visit_value\*(C'\fR.
.ie n .IP "visit_ref $value" 4
.el .IP "visit_ref \f(CW$value\fR" 4
.IX Item "visit_ref $value"
Generic recursive visitor. All non blessed values are given to this.
.Sp
\&\f(CW\*(C`visit_object\*(C'\fR can delegate to this method in order to visit the object
anyway.
.Sp
This will check if the visitor can handle \f(CW\*(C`visit_$reftype\*(C'\fR (lowercase), and if
not delegate to \f(CW\*(C`visit_value\*(C'\fR instead.
.ie n .IP "visit_array $array_ref" 4
.el .IP "visit_array \f(CW$array_ref\fR" 4
.IX Item "visit_array $array_ref"
.PD 0
.ie n .IP "visit_hash $hash_ref" 4
.el .IP "visit_hash \f(CW$hash_ref\fR" 4
.IX Item "visit_hash $hash_ref"
.ie n .IP "visit_glob $glob_ref" 4
.el .IP "visit_glob \f(CW$glob_ref\fR" 4
.IX Item "visit_glob $glob_ref"
.ie n .IP "visit_code $code_ref" 4
.el .IP "visit_code \f(CW$code_ref\fR" 4
.IX Item "visit_code $code_ref"
.ie n .IP "visit_scalar $scalar_ref" 4
.el .IP "visit_scalar \f(CW$scalar_ref\fR" 4
.IX Item "visit_scalar $scalar_ref"
.PD
These methods are called for the corresponding container type.
.ie n .IP "visit_value $value" 4
.el .IP "visit_value \f(CW$value\fR" 4
.IX Item "visit_value $value"
If the value is anything else, this method is called. The base implementation
will return \f(CW$value\fR.
.ie n .IP "visit_hash_entries $hash" 4
.el .IP "visit_hash_entries \f(CW$hash\fR" 4
.IX Item "visit_hash_entries $hash"
.PD 0
.ie n .IP "visit_hash_entry $key, $value, $hash" 4
.el .IP "visit_hash_entry \f(CW$key\fR, \f(CW$value\fR, \f(CW$hash\fR" 4
.IX Item "visit_hash_entry $key, $value, $hash"
.PD
Delegates to \f(CW\*(C`visit_hash_key\*(C'\fR and \f(CW\*(C`visit_hash_value\*(C'\fR. The value is passed as
\&\f(CW$_[2]\fR so that it is aliased.
.ie n .IP "visit_hash_key $key, $value, $hash" 4
.el .IP "visit_hash_key \f(CW$key\fR, \f(CW$value\fR, \f(CW$hash\fR" 4
.IX Item "visit_hash_key $key, $value, $hash"
Calls \f(CW\*(C`visit\*(C'\fR on the key and returns it.
.ie n .IP "visit_hash_value $value, $key, $hash" 4
.el .IP "visit_hash_value \f(CW$value\fR, \f(CW$key\fR, \f(CW$hash\fR" 4
.IX Item "visit_hash_value $value, $key, $hash"
The value will be aliased (passed as \f(CW$_[1]\fR).
.ie n .IP "visit_array_entries $array" 4
.el .IP "visit_array_entries \f(CW$array\fR" 4
.IX Item "visit_array_entries $array"
.PD 0
.ie n .IP "visit_array_entry $value, $index, $array" 4
.el .IP "visit_array_entry \f(CW$value\fR, \f(CW$index\fR, \f(CW$array\fR" 4
.IX Item "visit_array_entry $value, $index, $array"
.PD
Delegates to \f(CW\*(C`visit\*(C'\fR on value. The value is passed as \f(CW$_[1]\fR to retain
aliasing.
.ie n .IP "visit_tied $object, $var" 4
.el .IP "visit_tied \f(CW$object\fR, \f(CW$var\fR" 4
.IX Item "visit_tied $object, $var"
When \f(CW\*(C`tied_as_objects\*(C'\fR is enabled and a tied variable (hash, array, glob or
scalar) is encountered this method will be called on the tied object. If a
valid mapped value is returned, the newly constructed result container will be
tied to the return value and no iteration of the contents of the data will be
made (since all storage is delegated to the tied object).
.Sp
If a non blessed value is returned from \f(CW\*(C`visit_tied\*(C'\fR then the structure will
be iterated normally, and the result container will not be tied at all.
.Sp
This is because tying to the same class and performing the tie operations will
not yield the same results in many cases.
.ie n .IP "retain_magic $orig, $copy" 4
.el .IP "retain_magic \f(CW$orig\fR, \f(CW$copy\fR" 4
.IX Item "retain_magic $orig, $copy"
Copies over magic from \f(CW$orig\fR to \f(CW$copy\fR.
.Sp
Currently only handles \f(CW\*(C`bless\*(C'\fR. In the future this might be expanded using
Variable::Magic but it isn't clear what the correct semantics for magic
copying should be.
.IP "trace" 4
.IX Item "trace"
Called if the \f(CW\*(C`DEBUG\*(C'\fR constant is set with a trace message.
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
This object can be used as an \f(CW\*(C`fmap\*(C'\fR of sorts \- providing an ad-hoc functor
interface for Perl data structures.
.PP
In void context this functionality is ignored, but in any other context the
default methods will all try to return a value of similar structure, with it's
children also fmapped.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
Data::Visitor is a Moose class, so it should be subclassed using Moose.
.PP
Then override the callback methods in any way you like. To retain visitor
behavior, make sure to retain the functionality of \f(CW\*(C`visit_array\*(C'\fR and
\&\f(CW\*(C`visit_hash\*(C'\fR.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Add support for \*(L"natural\*(R" visiting of trees.
.IP "\(bu" 4
Expand \f(CW\*(C`retain_magic\*(C'\fR to support tying at the very least, or even more with
Variable::Magic if possible.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::Rmap, Tree::Simple::VisitorFactory, Data::Traverse
.PP
<http://en.wikipedia.org/wiki/Visitor_pattern>,
<http://www.ninebynine.org/Software/Learning\-Haskell\-Notes.html#functors>,
<http://en.wikipedia.org/wiki/Functor>
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Yuval Kogman <nothingmuch@woobling.org>
.IP "\(bu" 4
Marcel Gru\*:nauer <marcel@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2013 by Yuval Kogman.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
